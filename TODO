Отказаться от project.
Вместо этого иметь глобальный engine.

Отказаться от контента?





Сид это просто тип record.



У персонажа есть метод recap.
Этот метод берет диалог персонажа и обращаясь к контентному объекту.



Лор мира
Стартовое описание города
Собственная хроника
Диалоги
Рекапнутые диалоги
Конфлюкс



Когда двигаем мир:
1) Пробегаем по всем историям и замыкаем все разговоры.
2) Пробе



Когда разговариваем:

- Интро агента
- Биография агента
- Лор мира
- Сид истории
- Все записи (включая и converstation и conversationRecaps, но только этого персонажа)


Когда генерим новую запись в соло:
- Интро сторителлера
- Лор мира
- Сид истории
- Все записи (исключая conversation, только рекапы)



Когда генерим новую запись в конфлюксе:
- Интро конфлюкса
- Лор мира
- Сид обеих историй, по очереди.
- Все записи обеих историй (исключая conversation), отсортированные по айди истории




Когда идет конфлюкс, то он является источником ивентов.






У нас есть 2 истории.

У них есть какие-то летописи, там в том числе диалоги



Есть событие трех типов.














1) Спланировать все на бумажке
2) Написать базовый цикл заново
3) Сделать клиент, который разбирается в api

1) Убрать params и settings в верхнюю панельку

Есть world. В нем много stories


Есть story. В нем есть characters и storyline.
У world есть turn. Все истории имеют текущий ход мира



Есть агент, который наполняется по-разному.


Агент для валидатора:

- Инструкция (system, "ты - валидатор")
- Критерии (system)
- Задание (user)

Агент для персонажа
- Инструкция
- Прошлые диалоги (количество)
- Последняя реплика


Агент для сторителлера

- Инструкция
- Описание мира
- Правила (system)
- Какой-то сторилайн



Агент для рекаппера
- Инструкция
- Сторилайн



У истории есть:
 - Владелец
 - Переменные


Прошел ход N.
Игрок может спокойно разговаривать с каждым персонажем. Этот разговор записан как разговор, имевший место между N и N+1 ходом.
Как только мир нажимает новый ход, мы генерим новый этап всех историй.

Сторителлер получает все разговоры со всеми персонажами и все события (потом).
Сторителлер генерирует новую запись в сторилайне.
Если в результате истории сторилайн стал слишком длинным, мы рекаппим какую-то часть историй.





План:

1) Забиваю на телеграм, делаю полнофункциональный плей в редакторе
2) Рефактор игровой логики











Нормальное проксирование команд через плеера и юзера


Рефакторинг какой-то? Убрать хаки, сделанные наспех.
Тестами еще можно покрыть попробовать.


Сборка контента все-таки полезна, иначе потонем в адресации дочерних



Ввести понятие enum
Ввести полям значение по умолчанию, которое отражается в схеме. Тогда если оно ридонли, то можно делать нестед таблички.
Вводим дескрипшены.
Нужно придумать контент-дампы и ресторы.
Надо добавить возможность писать в телегу по инициативе сервера.
Кажется, что игровые чаты можно было бы и хранить. Вроде не особо жалко.
Нужно описание ходов

Есть сторителлер. Этот сторителлер генерирует историю по запросу.
Есть обсуждатор. Этот обсуждатор получает историю на данный момент + какой-то дополнительный контекст.
У обсуждатора есть условие выхода из диалога. Что делать с неактивностью?
У обсуждатора есть дефолтная строка "позвать".
Вводим понятие ридонли полей, чтобы нельзя было менять.





Есть валидатор, которого можно назначить каждому из агентов.

Есть рекаппер, ему нужно придумать название. Он умеет получать какую-то пачку данных и собирать из нее что-то.
Он это собирает в виде сообщения.
Это сообщение кладется в игру в какое-то специальное хранилище, которое называется итоги разговоров.
По идее разговоров может быть несколько.


У игры есть перееменнные:
{cityName}, {cityDescription}, {chronicle}, плюс еще какие-то кастомные

Эти переменные можно использовать внутри текста, чтобы собрать какой-то промт.


У обсуждатора есть название переменной в контексте игры, под которой будет храниться его результат.
У сторителлера тоже может что-то храниться.

nextTurn генерирует что-то для всех сторителлеров игры.





Есть агент. У него есть чат. Этот чат всегда хранится целиком. Не жалко.
У агента есть тип - выбор одного из enum.

У агента есть:
Intro - Вводный текст от системы
Guideline - Правила
Task - формулировка задания
resultVar - переменная в которую кладется result
resultText - формат текста с результатом
agentType - тип агента (хронист, рекаппер, продюсер) - а надо ли?
Модель - провайдер, модель, температура

Переменные агента - chat, lastMessage




У игры есть инициализирующие агенты:
	Игра на старте вызывает агенты в соответствующем порядке. Каждый из них кладет в определенную глобальную переменную свой резалт.

У игры есть nextTurn, который вызывает срабатывание определенных агентов с определенным переменными

У игры есть переменные
	Они делятся на глобальные, контекстные и turn-переменные




У игры есть:
	Сторителлер (один). Он отвечает за главный поток
	Болтуны (любое количество).






Можно оптимизировать на уровне клиента через useContent. 
Там по стораджам разбиты схемы и объекты.
Сторадж на getSchema запоминает схему
по getAll сторадж возвращает всякое


Хак. Каждый сторадж на старте выполяет getAll.
resolveChild по этому списку итерирует, а не пользуется монгой.





7) Плей в админке - нужно ли?
8) Купить и настроить домен - можно забить
4) Нужна ли система доступов? Кажется, что можно просто спрятать лишнее из клиента и оставить ENV-параметр.



4) По хорошему сделать мануальный роутинг

Окно чата:
Если последний был не юзер, можно написать
Отредактировать старое сообщение.


Переименовать play в play

Админка:
Авторизация (через лог+пасс). Телеграмовскую, кажется, не нужно
Вообще играть планируется в телеге, кажется.
Ввести понятие baseFields, поля верхнего уровня
Массивы
Сборка контента в админку и интерфейс для оперирования
Кэширование двеллеров
Ввести понятие дататайпов и филдов

Телеграм:
Опросник в телеге

Окно игры:
Перегенерить последнюю хронику
Удалить последнее сообщение в чате

Точно на потом:
Строки и переводы
Все еще можно клонировать темплейты
Понять, на каком этапе будет озвучка. Наверное это свойство телеграм бота

Клиент:
Переделать роутер наконец-то

Отладка:
Логирование
Сделать страницу для вызывалки api случайного двеллера
Постраничку, фильтры и сортировку пора (в т.ч. в куках)


// https://i.ibb.co/vcyK4kp/LOGO.png







А теперь все меняем.


Теперь каждый двеллер будем загружать.




Делаем loadLock - это что-то типа кэша, но для загрузки?







какие-то штуки постоянно держатся в памяти?



/new_game (default)

/new_scenario



Что нам надо

turnVariables - хранилище переменных хода



Хронисту нужно либо дать все 



Как устроен мультиплеер.

В какой-то момент в хронику начинают попадать



Надо назвать game как-то иначе. Story.
У нее есть storyteller. Он всегда один.


У сценария есть настройка:

Как называются ходы
Кто такой игрок (описание)
Агент-сторителлер
Агенты-инициализаторы
Агенты-nextTurn
Текстовые переменные которые нужно ввести для старта.

История в общем случае это какая-то пошаговая штука. Сторителлер делает шаг, а дальше игрок может коммуницировать с разными агентами.


Все это кладется в переменные {turn.scsdcd}



Инициализация вызывает агентов по очереди
nextTurn вызывает агентов по очереди


Агент прям создается новый? Пока положим так.



Загрузили игру.
У нее под ключом сценарий что-то лежит.

Нажимаем старт. Нам говорят "Введите переменную".
Если не говорят, то произошел старт.

По очереди вызываем всех агентов с их тасками.
Каждый из них кладет резалт в какие-то переменные.
Причем как именно формируется резалт может определяться разными способами - надо подумать.
В конце, после всех резалтов, вызывается сторителлер, генерирует новую запись в историю.
Потом удаляются все ходовые переменные игры.


У игры есть "болтушка". Это с кем мы болтаем. Это агент с типом болтушка.


Есть генераторы
Есть болтушкины
Есть валидаторы (отличаются ли они от генераторов?)

Игрок может в любое время коммуницировать с каждым агентом.
У сценария есть дефолтный болтолог.

У болтушкина есть роль агента и роль игрока
Резалт болтушкина это строка форматированная по ролям.


Когда мы нажимаем next.
Мы собираем промты.
У промта есть условие наличия переменных.

Есть заголовок результата:

У storyteller это story so far
У болтолога это Conversation that took place on {result}

У каждого агента есть

{chat} - отформатированное содержимое чата
{lastMessage} - последнее сообщение

Соответственно хронист продюсит следующее:
{cityDescription}

Chronicle so far:
{story}

{turnName}
{lastMessage}


Chancellor продюсит следующее
Conversation that took place {turnName}:

{chat}


У игры соответственно, есть вкладочки для каждого болтальщика.
Есть дефолтный болтальщик (а может и нет).


у переменных есть свойства всякие там.


sync - template



Master.exportContent = async function(data) {
	let result = {}
	if (data.objects) {
		result.objects = await this.contentDb.objects.find({}).toArray();
	}
	if (data.templates) {
		result.templates = await this.contentDb.templates.find({}).toArray();
	}
	return result;
}

Master.importContent = async function(data) {
	let { templates, objects } = data;
	if (templates) {
		templates.forEach(tpl => tpl._id = ObjectId(tpl._id));
		await this.contentDb.templates.deleteMany({});
		await this.contentDb.templates.insertMany(templates);
	}
	if (objects) {
		objects.forEach(obj => obj._id = ObjectId(obj._id));
		await this.contentDb.objects.deleteMany({});
		await this.contentDb.objects.insertMany(objects);
	}
}



import { Button } from 'antd';
import { DownloadOutlined } from '@ant-design/icons';

export const DownloadJSON = (props) => {

	const download = () => {
		let json = JSON.stringify(props.data, undefined, 2);
		const element = document.createElement('a');
		const file = new Blob([json], { type: 'text/plain' });
		element.href = URL.createObjectURL(file);
		element.download = `${props.filename}.json`;
		document.body.appendChild(element); // Required for this to work in FireFox
		element.click();
	};

	if (!props.filename || !props.data) return <>...</>;
	return <Button icon=<DownloadOutlined /> onClick={download}>
		{props.filename}
	</Button>;
}




В контенте есть агенты. получается они просто агенты. Каждый из них по таску что-то получает.
После каждой таски агент сохраняет резалт каким-то образом в указанную переменную.


Когда дергаем nextTurn, то все context и turn переменные сбрасываются. 

Генератор случайных событий.



Переменные игры
{ turnName }
{ cityName }

Агента инициализируют. У него есть:

Интро
Правила
Модель


Они могут использовать всякое разное.

{ story.name }

Все агенты одинаковые
{ context.chat }
{ context.task }
{ context.chat }


Как работает конфлюкс


У конфлюкса есть ссылка на несколько городов.

Наверное у конфлюкса есть еще и какой-то промт.
Когда идет nextTurn, то вместо игры мы жамкаем nextTurn у конфлюкса





Конфлюкс это несколько историй.


Мы берем и склеиваем по шагам их хроники.




Нужно ли связываться с переменными. Кажется что нужно.



Есть сторителлер, он один. У него есть записи в хрониках. Он не совсем обычный агент.

Каждый раз, когда он что-то генерирует, он кладет это в хронику.




Есть хронист, у него фиксированные правила, но у него есть lore, cityDescription, cityName



Есть переменные игры - это переменные, которые нужно взвести на старте. 

Есть переменная context.story - это просто текст истории?


Как бы сформулировать, как мы рекаппим. Кажется, пока не думаю об этом, а потом будут бриктришки!



1) Рекап истории. На каком-то определенном ходу можно сказать, что надо рекапнуть все, что было до этого хода. И дать ссылку на агента, который это делает.

У хроники есть ход начала и ход конца. А еще есть свойство reccaped. Потом можно будет сделать схлопывание

Соответственно у игры есть полная хроника и текущая хроника. Текущая хроника может храниться и в переменной.


1) Слишком большая история для агента. 
Лечится методом "историю в сообщения". 
Все агенты пока что по умолчанию получают всю историю.


У агента есть. 
Есть болтальщик. Его описание это некоторый текст (пока можно считать что контстанта).




Пробегаем по всем, с кем болтали.
Каждый из них рекапается.
Дальше берем и забрасываем события, которые должны были произойти.

Все это сбрасываем в сторителлера и просим сгенерировать новую запись.


Он генерирует result, мы добавляем его в хронику.


Как мы добавляем переменную в текст. Если это массив, то одно, если не массив-то другое.






Есть понятие story. У истории есть сторителлер.
История состоит из записей вида ход+сюжет


Помимо этого у истории есть набор дополнительных событий.



Когда мы хотим сгенерировать историю, мы:

Произошли следующие события:

{turn}
{event}

{turn}
{event}



Как работает conflux? 
Конфлюкс это объединение нескольких история.


У истории есть ссылка на конфлюкс.
Конфлюкс имеет агента. 

Он получает всю хронику, а так же всю историю в отдельных сообщениях.
Она отсортирована по ходам.

Дальше ему сказано, что нужно развить сюжет. Он пишет какой-то текст, который описывает развитие сюжета.
Дальше этот промт отправляется в виде таски сторителлеру. 




Есть класс сторителлер
Есть класс валидатор
Есть класс интерлокутор






Есть двеллер провайдер.
Мы загружаем двеллера и запрашиваем у него хэлп. 
Из него строим апишку. Пока все это делать не хочется.


Есть стораджи.


Сборка контента
Страница игры



Есть world. У него есть scenarioId. Там есть лор

Дальше стартует игра.

Сторителлеру нужно:
Описание того, что делать
Описание лора
Правила
Прошлая хроника


Агенту в общем случае нужны:
Инструкции - система
Правила - система
Чат - как минимум одно сообщение от юзера




Имя города
Стартовое описание города


Есть понятие чата. Оно внешнее и полезно для чего угодно.
Там есть система и агент.
Агент получает какую-то инструкцию (интро), а так же получает что-то еще

Есть понятие чата. У чата есть сообщения от системы, от чего угодно, возможность добавить сообщение и ссылка на агента.
А не нужна чату ссылка на агента, там уже ничего нет.


Агент это какая-то бандурина, которая умеет тупо продолжать чат.





interlocutor. C ним стартуется чат.
Он получает какое-то описание



Создали игру.
Ввели все требуемые переменные, они лежат в отдельном сторадже.

{cityName}
{kingName} ??

Теперь нам нужно описание города.
Для этого мы обращаемся в сценарий. Он обращается к продюсерам (массиву продюсеров).

Продюсер это базовый агент.

Составляем ему пачку сообщений:

Инструкция.
Лор.
Правила.
Промт для генерации.

Дальше пробегаемся по полному списку сообщений, заменяя переменные на нужные значения.
Агент создает чат с этим всем. Дальше агент вызывает chat.continue(), а респонс закидывает в нужную переменную.
(добавить каких-то логов?).


Кажется, что мир может определять какие-то переменные.
Эти переменные добавляются в схему игры. То же самое, что с темплейтами, в целом. Только вот непонятно, как потом понимать, что переменные, а что нет. Кажется, что отдельно все-таки прикольнее.

Теперь у игры есть поле cityDescription.


У агента есть галочка "получать хронику". Если она есть, то агент впихивает хронику куда-то в свой чат.
У агента есть галочка "сохранять чат". Если она выставлена, то чат не одноразовый, а будет сохранен.

nextTurn(context)
Взводит в контекст переменные {world.newTurnName} и {world.oldTurnName};

Собираем контекст - список переменных (срезая с мира и себя).
Отправляем это дело в сторителлера.

У него есть
1) Инструкция
2) Лор игры
3) Правила
4) Хроника (каждая запись в отдельном сообщении), это по галочке.
5) Правила
6) Промт - юзер


Галочка "включать лор"

Галочка "включать хронику"

UserMessage.


Его результат добавляется в хронику.
Когда все игры это сделали, мы молодцы и мы можем как минимум двигать историю вперед, не влияя на нее.


===========



Теперь добавляем события.

В хронике может лежать coversation, event, record.


Игра может в определенный момент намешать событие в хронику какой-то игры.
Это просто намешивает событие.
У игры так же есть globalEvent - это намешать всем.





==========

Дальше добавляем болтушку.
У игры есть команда "сказать в чат".
Если нет чата, то мы создаем новый.

В правилах можем использовать какую-то переменную. А можем и не использовать.

В качестве промта используем реплику.

Болтальщик берет чат, докидывает в него реплику и делает continue.
Возвращает ответ.


Больше пока с чатом ничего не делаем.






Когда происходит nextTurn, мы собираем чат в строку (про ограничение по размеру пока не думаем).

Для этого нужно название результата "This conversation took place in {story.cityName} in {world.turn}"
А так же userNickname и agentNickname.

Эти поля объявлены на болтальщике.


Соответственно, если чат есть во время nextTurn, то мы обращаемся к болтальщику, собираем диалог.
Если есть настройка "рекапить", то рекапим. Если нет такой настройки, то пихаем сырой диалог.

Запихиваем диалог в хронику. Дальше идет штатный nextTurn.







=========

Какие получились агенты:

Storyteller


Interlocutor
Generator
Reteller
Validator

У них есть общие поля - правила и интро.
Получение хроники
Валидатор
Резалт в переменную



=========




Валидатор это вообще не агент, это псевдо агент.


Interlocutor не генерирует результат
Generator кладет ответ в какую-то переменную
Reteller кладет ответ в какую-то переменную













Каждый раз, когда история обращается к агенту, она сбрасывает свои переменные в контекст.



Есть конфиг, который собирает полный список классов на загрузке проекта.
Для этого мы пробегаемся по всему, что с точкой, а так же по _ (это значит просто ребенок);


Сначала собираем один глобальный конфиг. В нем есть ключ Traits. Он перечисляет разные трейты.
Трейт содержит конфиг и файл с прототипом этого трейта.

Загружаем все трейты.


Дальше начинаем собирать таблицу классов.

Пробегаем по всем узлам с точкой.
У каждого из таких узлов указан конфиг, в котором есть, в числе прочего, таблица трейтов.


Нам надо собрать класс и конфиг класса.
Сначала собираем пустую таблицу вокруг dweller, которая будет наш класс.

Дальше каждый ключ трейт в конфиге класса. Напротив ключа трейт может быть как булево значение, так и конфиг.

Если там конфиг, то мы:

Берем трейт и применяем его к текущей таблице, заменяя все методы и добавляя коллбэки.
Берем конфиг трейта и намешиваем его в конфиг класса. 
Берем конфиг который был в классе напротив трейта и намешиваем его к конфигу класса.
Тут можно доиграться, но пока кажется это не особо часто.



Имеем видоизмененный объект для этого класса и видоизмененный конфиг. Конфиг ломаем прям наживую, считаем что не жалко.

Закончили собирать класс?
Положили его собранный конфиг в Master.config (в прототип класса).
Положили класс по его id (заменяя model на _) в какую-нибудь таблицу для резолва в будущемю
Как только закончили собирать класс, можем пойти собрать его чайлдов.
Как только закончили собирать все, считаем, что мы молодцы.







Мы считываем трейты этого класса из конфига. 
Мы собираем конфиг этого класса и таблицу этого класса. 

После этого мы кладем этот класс в таблицу global.classesю